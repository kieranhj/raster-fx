Scrolltext Jam
~~~
December 2018

1) Billboard LEDs - DONE (again)
2) Multiple single character row scrollers at different speeds (STARTED)
3) Sinewave scroller at 16x16 or such - full screen using vrup/wrap - DONE (v1)
4) Vertical zoom scroller (8x8 glyph VRup in MODE 1) - DONE (v1)
5) Tile scroller (32x32 tiles panning around a larger map)
6) Large glyph scroller (assembled from 256 possible 8x8 tiles)
7) Single character scroller (sprites)
8) Vertical scroller 
9) Any 3D text, esp filled even if just a couple of glyphs
10) Compiled dot scroller


Vertical Zoom Scroller
~~~
8 character rows - each 160 columns
Column offset 0-7 pixels (begin just 0 and 4 pixels)
Fill rhs and lhs of each character row with bytes depending on pixels from glyph column
Use vrup to repeat rows (start with 8 times)

Extras:
- Use lookup tables for vrup to stretch, rotate, ripple
- Dither by using 2x scanlines for each char row
- Potentially add colour palette changes as well
- Use 4x sets of character rows for single pixel offsets
- Add mirror effect back
- Up to 16x16 font using 16 character rows

Compiled Dot Scroller
~~~
For each byte of dot:

; JSR to get here       ; 6c
LDA #pixel_data_imm     ; 2c 2b <- could be changed to a LDA pixel_data_zp
EOR screen_addr_abs     ; 4c 3b
STA screen_addr_abs     ; 4c 3b
; x num_bytes
RTS                     ; 6c 1b

So 10c per byte; 12c overhead for JSR/RTS
Say 30,000c max for plotting
Guess 8x24 dots minimum = 192 total
Gives ~156c per dot = (156-12)/10 ~= 14 bytes to plot
  oooo
 oooooo
 oooooo
  oooo
2 + 3 + 3 + 2 = 10 bytes
Which MODE? (Usually MODE 1)

Small dot
   ooo
  ooooo
   ooo
Would be maximum 6 bytes to plot (hopefully more often 4 bytes)

Cycles per dot = 6x10 + 12 = 72c
Max dots = 30,000 / 72 ~= 416
Assuming height of 8 could have 48 x 8 dots = 384 dots
How much code?
8 bytes code per byte plotted plus 1b RTS
6 x 8 + 1 = 49b per dot
Max bytes = 18,816 bytes - ouch!
Could save cycles & bytes by utilising duplicated data
E.g. sprite row 0 & 2 are the same
Need a nice way to generate pre-compiled dots and patterns - Python?
Start with 40 x 8 = 320 dots which comes in at <16K bytes code

Think precompilng more appropriate with a smaller number of larger sprites
rather than a large number of small sprites

Better to generate code for all pixel offset combinations instead?
So 0 <= x <= 3 and 0 <= y <= 7 with character address in ZP and Y as index?
Painful to span character row or precalc address of following row?
Depends how often this occurs! Presumably 50% of the time for 4 pixel high dot

Dot Tunnel
~~~
Use dot precompiler to generate circles instead of columns
Can animate maximum 640 dots per frame (maybe less?)
Need to erase one circle off and plot the next one
Therefore can only see 320 dots at a time but generate as many as needed for animation
Say 8 'frames' between circles
320 visible dots / 20 dots in a circle (say) = 16 circles visible
But generate 16 * 8 circles in code (assuming space)
Equivalent to 2560 dots
(Ended up as 20 dots in circle * 110 circles at step of 10 = 11 circles visible)

Done this but doesn't look good as tunnel is fixed animation - could do this with palette cycling!
Need to be able to plot circles quickly and precalc a nice path for them
Assume the circles are the sprites and generate code for each radius <=> depth?
But need to be able to plot them at any (x,y) coordinate
Can't have 32x combinations x 100 depth values
Could generate code that works across character row boundaries?
Could move to MODE 4 and plot single pixels for dots? (8x combos)
Clipping is a challenge for pre-computed circle plotting at arbitrary positions
Or super-fast single pixel plot in MODE4S by jump table on character row?

Alternatively have a table of (x,y) pixel positions to form a cirlce for given depth (radius)
Then it's a case of computing the centre point, adding the offset for each pixel and plotting individually :\
Suggest doing this the long-winded way to get the effect correct then optimise
Definitely restrict to 256x256 screen for simplicity

For tunnel, plot from back to front. Starting at index 0 draw tunnel depth 64
(but only actually plot every 8 circles) increasing the index each time.
Next frame, decrement the index but draw the tunnel starting from the next depth
